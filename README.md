# Deploy a Microservices Application on Openshift

### About
A demonstration on how to deploy a microservice application on Openshift and enabling CI/CD for the app. We will be deploying a voting application. Then packaging all the components we deployed to get a fully working voting application into a template and add a catalog item for it.

### Requirements
* An Openshift cluster. The demo will be done through the openshift web-console.

* A clone of the [The Voting application](https://github.com/dockersamples/example-voting-app). This is a sample voting application which provides an interface for a user to vote and another interface to show the results.
The application consists of various components such as the voting app which is a web application developed in Python to provide the user with an interface to choose between two options, a cat and a dog. When you make a selection the vote is stored in Redis. This vote is then processed by the worker which is an application written in .NET. The worker application takes the new vote and updates the persistent database which is PostgresSQL in this case. The PostgresSQL simply has a table with a number of votes for each category, cats and dogs. Finally the result of the vote is displayed in a web interface which is another web application developed in NodeJS. This resulting application rates the count of votes from the PostgresSQL database and display's it to the user.

### Steps
• Log into your web console and create a new application. I called mine `voting-application`

• Start by deploying the front-end application for the client that will be used for the vote. Since that is dependent on the Redis, we deploy the Redis service first. If you don't find a redis service in the service catalog, you can add one yourself from [openshift examples](https://github.com/openshift/origin/blob/master/examples/db-templates/redis-ephemeral-template.json) on Github. Copy its content and select `import YAML/JSON` option in the UI. Paste it in the pop-up area. Click create. Select save template and continue. Refresh the browser to see a new Redis service. It can now be selected to deploy a Redis service. Click it and follow the prompt. Leave all default values and specify a password for Redis, `redis_passsword`. That's the same password used in the voting app. Click create to deploy the Redis service. On deployment, keep note of the deplyment information.

• The next step is to deploy the front-end application. In the [voting app](https://github.com/dockersamples/example-voting-app) it is under the 'vote' folder. It is written in python so add a new python application to the project from the catalog. You cannot simply specify the url like in the previous step because the python project is nested in a folder called '/_vote_'. So select advanced options to specify a sub-directory within git. Provide the name, git url and set the context directory to the sub-directory where the project is, _i.e_ '/vote'. Leave all other settings to default and create the application. This will autimatically create a build and deplpyment confiuration. Once it is finished, simply select the link to access the app externally.
<Picture>
However, casting the vote creates an error. That is because we haven't specified the password used while deploying Redis anywhere in the voting app. Go back to the voting app front-end deployment config and add an environment variable `REDIS_PASSWORD`. And specify a password for Redis `redis_password`. Now casting a vote should work.

• Now for the second part of the application. The results service is dependent on the PostgreSQL service so we deploy that first. It is available as a catalog by default that will be used. The database service name must be the same name used by the applications to connect to the PostgreSQL database. In this case it is `db`. So in the Database Service Name field enter `db`. PostgreSQL Connection Username is `postgres_user`. PostgreSQL Connection Password is `postgress_password`. PostgreSQL Database Name is simply `postgres`. All of these values are used for simplicity and are not proper credentials. You can adjust the size to something small like `100Mi` since we're not storing much data. Click create to create the database service.

• Now to deploy the results-app. It is based on NodeJS. Add a NodeJS app from the catalog. As with the Python setup, select advanced options. Provide a name, the git repository url. The context is '_/result_' From the applications code in github, the app listens on port 4000. That can be overriden in the Build Configuration section of the advanced options. Add an environment variable called PORT, with value 8080 so the app is available on port 8080. Also add the same environment variable and value to the Deployment Configuration. Then click create. The progress can be monitored in the build page. Once deployed the app is available on the route url. Click on the link to access the results app. Modifying the vote count in the voting app doesn't affect the results yet. That's because the workers have not been deployed yet.

• The worker service will be deplyed using the Docker build strategy as opposed to Source to Image (S2I) strategy that we've been using. Select the Apache HTTP Server from the catalog. Select advanced options and provide a name, git url and context, '_/worker_'. Leave the rest to default and add the app. Ignore the automated build. Select the build configuration of the service. Click on actions in the top-right. Select edit YAML. Change the _strategy_ from 'sourceStrategy' to 'dockerStrategy'. Delete the '_from_' section. Change '_type_' to Docker. Click on save. Start build. The build goes through and pushes a new Docker image. Once the image is deployed, you can access the logs to see the votes being processed. Now changing the vote has an immediate effect.
